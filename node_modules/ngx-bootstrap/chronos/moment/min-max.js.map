{"version":3,"sources":["../../../.tmp/chronos/moment/min-max.ts"],"names":[],"mappings":"AAAA,oEAAoE;AACpE,0DAA0D;AAC1D,EAAE;AACF,yEAAyE;AACzE,+CAA+C;AAC/C,OAAO,EAAE,OAAO,EAAE,WAAW,EAAE,MAAM,sBAAsB,CAAC;AAC5D,OAAO,EAAE,OAAO,EAAE,QAAQ,EAAE,MAAM,uBAAuB,CAAC;AAE1D,gBAAgB,EAAY,EAAE,KAAwB;IACpD,IAAI,MAAc,CAAC;IACnB,IAAM,SAAS,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;IAC3B,EAAE,CAAC,CAAC,OAAO,CAAO,SAAS,CAAC,IAAI,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QACnD,MAAM,GAAG,SAAS,CAAC;IACrB,CAAC;IAAC,IAAI,CAAC,EAAE,CAAC,CAAC,OAAO,CAAO,KAAK,CAAC,CAAC,CAAC,CAAC;QAChC,MAAM,GAAG,KAAK,CAAC;IACjB,CAAC;IAED,EAAE,CAAC,CAAC,CAAC,MAAM,IAAI,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;QAC9B,MAAM,CAAC,IAAI,IAAI,EAAE,CAAC;IACpB,CAAC;IACD,IAAI,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;IACpB,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,EAAE,CAAC,EAAE,CAAC;QACvC,sDAAsD;QACtD,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,CAAC,CAAC,CAAC,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;YAC7D,GAAG,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QAClB,CAAC;IACH,CAAC;IAED,MAAM,CAAC,GAAG,CAAC;AACb,CAAC;AAED,6BAA6B;AAC7B,MAAM;IACJ,4CAA4C;IAD1B,cAAe;SAAf,UAAe,EAAf,qBAAe,EAAf,IAAe;QAAf,yBAAe;;IAGjC,MAAM,CAAC,MAAM,CAAC,QAAQ,EAAE,IAAI,CAAC,CAAC;AAChC,CAAC;AAED,MAAM;IACJ,4CAA4C;IAD1B,cAAe;SAAf,UAAe,EAAf,qBAAe,EAAf,IAAe;QAAf,yBAAe;;IAGjC,MAAM,CAAC,MAAM,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAC/B,CAAC","file":"min-max.js","sourceRoot":"","sourcesContent":["// Pick a moment m from moments so that m[fn](other) is true for all\n// other. This relies on the function fn to be transitive.\n//\n// moments should either be an array of moment objects or an array, whose\n// first element is an array of moment objects.\nimport { isArray, isDateValid } from '../utils/type-checks';\nimport { isAfter, isBefore } from '../utils/date-compare';\n\nfunction pickBy(fn: Function, dates: Date[] | Date[][]): Date {\n  let _dates: Date[];\n  const _firstArg = dates[0];\n  if (isArray<Date>(_firstArg) && dates.length === 1) {\n    _dates = _firstArg;\n  } else if (isArray<Date>(dates)) {\n    _dates = dates;\n  }\n\n  if (!_dates || !_dates.length) {\n    return new Date();\n  }\n  let res = _dates[0];\n  for (let i = 1; i < _dates.length; ++i) {\n    // if (!moments[i].isValid() || moments[i][fn](res)) {\n    if (!isDateValid(_dates[i]) || fn.call(null, _dates[i], res)) {\n      res = _dates[i];\n    }\n  }\n\n  return res;\n}\n\n// TODO: Use [].sort instead?\nexport function min(...args: Date[]): Date {\n  // const args = [].slice.call(arguments, 0);\n\n  return pickBy(isBefore, args);\n}\n\nexport function max(...args: Date[]): Date {\n  // const args = [].slice.call(arguments, 0);\n\n  return pickBy(isAfter, args);\n}\n"]}