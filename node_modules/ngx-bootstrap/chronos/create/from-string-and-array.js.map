{"version":3,"sources":["../../../.tmp/chronos/create/from-string-and-array.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,aAAa,EAAE,OAAO,EAAE,MAAM,SAAS,CAAC;AACjD,OAAO,EAAE,eAAe,EAAE,MAAM,iBAAiB,CAAC;AAClD,OAAO,EAAE,yBAAyB,EAAE,MAAM,0BAA0B,CAAC;AAErE,+CAA+C;AAC/C,MAAM,mCAAmC,MAAyB;IAChE,IAAI,UAAU,CAAC;IACf,IAAI,UAAU,CAAC;IACf,IAAI,WAAW,CAAC;IAChB,IAAI,YAAY,CAAC;IAEjB,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,EAAE,IAAI,MAAM,CAAC,EAAE,CAAC,MAAM,KAAK,CAAC,CAAC,CAAC,CAAC;QACzC,eAAe,CAAC,MAAM,CAAC,CAAC,aAAa,GAAG,IAAI,CAAC;QAE7C,MAAM,CAAC,aAAa,CAAC,MAAM,CAAC,CAAC;IAC/B,CAAC;IAED,IAAI,CAAC,CAAC;IACN,GAAG,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;QACtC,YAAY,GAAG,CAAC,CAAC;QACjB,UAAU,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;QACvC,EAAE,CAAC,CAAC,MAAM,CAAC,OAAO,IAAI,IAAI,CAAC,CAAC,CAAC;YAC3B,UAAU,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;QACtC,CAAC;QACD,UAAU,CAAC,EAAE,GAAG,MAAM,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAC7B,yBAAyB,CAAC,UAAU,CAAC,CAAC;QAEtC,EAAE,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;YACzB,QAAQ,CAAC;QACX,CAAC;QAED,0EAA0E;QAC1E,YAAY,IAAI,eAAe,CAAC,UAAU,CAAC,CAAC,aAAa,CAAC;QAE1D,YAAY;QACZ,YAAY,IAAI,eAAe,CAAC,UAAU,CAAC,CAAC,YAAY,CAAC,MAAM,GAAG,EAAE,CAAC;QAErE,eAAe,CAAC,UAAU,CAAC,CAAC,KAAK,GAAG,YAAY,CAAC;QAEjD,EAAE,CAAC,CAAC,WAAW,IAAI,IAAI,IAAI,YAAY,GAAG,WAAW,CAAC,CAAC,CAAC;YACtD,WAAW,GAAG,YAAY,CAAC;YAC3B,UAAU,GAAG,UAAU,CAAC;QAC1B,CAAC;IACH,CAAC;IAED,MAAM,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,EAAE,UAAU,IAAI,UAAU,CAAC,CAAC;AACzD,CAAC","file":"from-string-and-array.js","sourceRoot":"","sourcesContent":["import { DateParsingConfig } from './parsing.types';\nimport { createInvalid, isValid } from './valid';\nimport { getParsingFlags } from './parsing-flags';\nimport { configFromStringAndFormat } from './from-string-and-format';\n\n// date from string and array of format strings\nexport function configFromStringAndArray(config: DateParsingConfig): DateParsingConfig {\n  let tempConfig;\n  let bestMoment;\n  let scoreToBeat;\n  let currentScore;\n\n  if (!config._f || config._f.length === 0) {\n    getParsingFlags(config).invalidFormat = true;\n\n    return createInvalid(config);\n  }\n\n  let i;\n  for (i = 0; i < config._f.length; i++) {\n    currentScore = 0;\n    tempConfig = Object.assign({}, config);\n    if (config._useUTC != null) {\n      tempConfig._useUTC = config._useUTC;\n    }\n    tempConfig._f = config._f[i];\n    configFromStringAndFormat(tempConfig);\n\n    if (!isValid(tempConfig)) {\n      continue;\n    }\n\n    // if there is any input that was not parsed add a penalty for that format\n    currentScore += getParsingFlags(tempConfig).charsLeftOver;\n\n    // or tokens\n    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;\n\n    getParsingFlags(tempConfig).score = currentScore;\n\n    if (scoreToBeat == null || currentScore < scoreToBeat) {\n      scoreToBeat = currentScore;\n      bestMoment = tempConfig;\n    }\n  }\n\n  return Object.assign(config, bestMoment || tempConfig);\n}\n"]}